<div class="modal">
    <div class="modal-window">

        <div class="modal-header">
            <h3>LABOT PIEVIENOTƒÄS PRECES</h3>
        </div>

        <div class="modal-body">

            @foreach (var group in Items.GroupBy(i => i.VersionId))
            {
                var first = group.First();

                <div class="product-block">
                 
                    <!-- HEADER + SUMMARY IN ONE ROW -->

                    <div class="product-header-row">
    <div class="product-title">
        <strong>@first.ProductName</strong>
        @if (!string.IsNullOrWhiteSpace(first.VersionName))
        {
            <span class="version">(@first.VersionName)</span>
        }
    </div>

    <div class="product-totals">
        <span>KOPƒÄ <span class="total-type">(STOCK)</span>: @group.Where(i => !i.IsAssembly).SelectMany(i => i.Batches).Sum(b => b.Qty)</span>
<span>KOPƒÄ <span class="total-type">(ASSEMBLY)</span>: @group.Where(i => i.IsAssembly).SelectMany(i => i.Batches).Sum(b => b.Qty)</span>

    </div>
</div>

                    <!-- BATCH TABLE -->
 <div class="batch-block">                   
                    <table class="sales-edit-table">
<thead>
    <tr>
        <th rowspan="2" class="col-batch">Batch</th>

        <th colspan="2" class="group-stock">STOCK</th>
        <th colspan="2" class="group-assembly">ASSEMBLY</th>

        <th rowspan="2" class="col-delete">Dzƒìst</th>
    </tr>
    <tr>
        <th class="col-available">Pieejams</th>
        <th class="col-sell">PƒÅrdot</th>

        <th class="col-available">Pieejams</th>
        <th class="col-sell">PƒÅrdot</th>
    </tr>
</thead>

                        <tbody>
                            @foreach (var item in group)
                            {
@for (int batchIndex = 0; batchIndex < item.Batches.Count; batchIndex++)
{
    var batch = item.Batches[batchIndex];

   <tr @key="@($"{item.VersionId}-{item.IsAssembly}-{batch.BatchCode}")">


        <td class="batch-code">@batch.BatchCode</td>

        <td>@(item.IsAssembly ? "-" : batch.AvailableQty.ToString())</td>

<td>
    @if (!item.IsAssembly && item.InStock > 0)
    {
        <input type="number"
       class="qty-input"
       value="@batch.Qty"
       min="0"
       max="@batch.AvailableQty"
       @oninput="e =>
       {
           if (int.TryParse(e.Value?.ToString(), out var v))
               batch.Qty = Math.Min(v, batch.AvailableQty);
           else
               batch.Qty = 0;
       }" />

    }
    else if (!item.IsAssembly)
    {
        <span>-</span>
    }
</td>

<td>@(item.IsAssembly ? batch.AvailableQty.ToString() : "-")</td>

<td>
    @if (item.IsAssembly && item.InStock > 0)
    {
        <input type="number"
       class="qty-input"
       value="@batch.Qty"
       min="0"
       max="@batch.AvailableQty"
       @oninput="e =>
       {
           if (int.TryParse(e.Value?.ToString(), out var v))
               batch.Qty = Math.Min(v, batch.AvailableQty);
           else
               batch.Qty = 0;
       }" />

    }
    else if (item.IsAssembly)
    {
        <span>-</span>
    }
</td>

<td class="col-delete">
    <button type="button"
        class="delete-btn"
        title="Dzƒìst rindu"
        @onclick="() => RemoveBatch(item, batch.BatchCode)">
    üóëÔ∏è
</button>

</td>

    </tr>
}

                            }
                            </tbody>

                    </table>
</div>
                </div>
            }

        </div>

        <!-- FOOTER BUTTONS (RESTORED) -->
        <div class="modal-footer">
   
   <button @onclick="ConfirmUpdate">ATJAUNOT</button>


@*
/// Hook the ATCELT button to invoke the OnClose EventCallback.
/// Do not change business logic or method names.
/// The button must close the dialog.
*@
            <button @onclick="() => OnClose.InvokeAsync()">ATCELT</button>

        </div>

    </div>
</div>

@code {
    [Parameter] public IReadOnlyList<SalesCartItem> Items { get; set; }
        = Array.Empty<SalesCartItem>();

    [Parameter] public EventCallback OnCancel { get; set; }
    [Parameter] public EventCallback<List<SalesCartItem>> OnSave { get; set; }

    [Parameter] public EventCallback OnClose { get; set; }


void RemoveBatch(SalesCartItem item, string batchCode)
{
    var batch = item.Batches.FirstOrDefault(b => b.BatchCode == batchCode);
    if (batch != null)
    {
        item.Batches.Remove(batch);
        StateHasChanged();
    }
}

[Inject] private IJSRuntime JS { get; set; } = default!;

private async Task ConfirmUpdate()
{
    var ok = await JS.InvokeAsync<bool>(
        "confirm",
        "Vai atjaunot datus?"
    );

    if (!ok)
        return; // paliek popupƒÅ, nekas nemainƒÅs

    await OnSave.InvokeAsync(Items.ToList());
}


}
